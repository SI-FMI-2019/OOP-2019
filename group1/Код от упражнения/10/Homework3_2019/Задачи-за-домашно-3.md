# **Задача**

Предложено е примерно именуване на класовете, полетата и функциите. По ваше желание може да ги промените, за да са по ясни и лесни за разбиране. При необходимост реализирайе конструктори, деструктор, getters, setters, допълнителни методи.

Реализирайте клас **Point2D**, който има:

- Координата **double X**
- Координата **double Y**
- Метод **getDistanceTo**, който приема **Point2D** и пресмята разстоянието до него от текущия обект

Реализирайте клас **Point3D**, който наследява **Point2D** и има:

- Координата **double Z**
- Метод **getDistanceTo**, който приема **Point3D** и пресмята разстоянието до него от текущия обект

Реализирайте **абстрактен** клас **Entity** [^abstract], който има:

- **Id** - Цяло число, генерира се автоматично, всеки обект има уникално **Id**
- **Name** - string
- **Location**, който е или **Point2D** или **Point3D** [^location]
- **Enum Type**, който ще следи какъв е типа на наследените класове на **Entity**. *Пояснение: Или реализирайте Enum-а в класа **Entity** или в глобалния scope, но ако е в глобалния внимавайте да не го замърсите [^enums]*
- Метод **isAlive**, който винаги връща **true**
- Метод **getDistanceTo2D**, който приема **Entity** и връща разстоянието между него и текущия обект като третира **Location** като **Point2D**
- Метод **getDistanceTo**, който приема **Entity** и връща разстоянието до него от текущия обект. *Пояснение: Ако и двата обекта пазят 3D **Location**, то трябва да се пресметне разстоянието им като се използват и трите координати. Ако поне единият обект има 2D **Location**, то трябва да се пресметне разстоянието им като се използват само X,Y координатите им*
- Метод **MoveTo**, който приема аргумент **Point3D** или **Point2D** и променя **Location** на текущия обект да е същия както на аргумента. *Пояснение: Ако аргументът и **Location** в текущия обект са от един и същ тип да се копира нормално. Ако аргументът и **Location** са от различен тип да се копира само информацията, която може. Ще се получи загуба на данни, но не е фатално*
- Метод **MoveTo**, който приема **Entity** и променя **Location** на текущия обект да е същия като на подадения аргумент. *Пояснение: Използва същите правила като горния метод*

Реализирайте клас **Player**, който наследява **Entity** и има:

- **Enum Type = Player**
- **Damage** - цяло число
- **Health** - цяло число
- Метод **isAlive**, който връща **true**, ако **Health > 0**
- Метдо **attack**, който приема **Player** или **Mob** и отнема **Damage** от неговия **Health** ако дистанцията между двата обекта е по-малка от **5** [^attack]

Реализирайте клас **NPC**, който наследява **Entity** и има:

- **Enum Type = NPC**
- Метдо **isAlive**, който винаги връща **true**

Реализирайте клас **Mob**, който наследява **Entity** и има:

- **Enum Type = Mob**
- **Damage** - цяло число
- **Health** - цяло число
- Метод **isAlive**, който връща **true**, ако **Health > 0**
- Метдо **attack**, който приема **Player** и отнема **Damage** от неговия **Health** ако дистанцията между двата обекта е по-малка от **5**

Реализирайте клас **Environment** [^singleton], който има:

- **Entities** - един vector, който може да съдържа **Player** и **NPC** и **Mob** [^polymorphicvector]
- Метод **add**, който може да добавя **Player**, **NPC** и **Mob** към **Entities** [^attack]
- Метод **getEntity**, който по подаден индекс **index** връща елемента на позиция **index** в **Entities**
- Метод **generateEntities**, който създава няколко **Entity** от различен тип и ги добавя към **Entities**
- Метод **destroyEntities**, който изчиства всички обекти в **Entities**
- Метод **getClosestEntity**, който приема **Player** и **Type** и връща **Entity** от вектора **Entities**, който е най-близко до подадения **Player** и има същия тип като подадения аргумент

Реализирайте главна програма, която:

- Създава един **Player** *Player1*
- Създава **Environment**
- Напълва **Environment**-а с няколко **Entity** от различен тип
- *Player1* минава и атакува всички **Mob** от **Environment**-а като реда в който го прави е от най-близки, към най-далечни

**Hints**

[^location]: Указател към Point2D (да използва полиморфизъм) или може да се реализира в отделен клас Location, който има указател към Point2D
[^enums]: [https://stackoverflow.com/questions/2503807/declaring-an-enum-within-a-class](https://stackoverflow.com/questions/2503807/declaring-an-enum-within-a-class)
[^abstract]: Абстрактен клас  е или клас, който има поне един чисто виртуален метод [https://stackoverflow.com/questions/1219607/why-do-we-need-a-pure-virtual-destructor-in-c](https://stackoverflow.com/questions/1219607/why-do-we-need-a-pure-virtual-destructor-in-c), или клас чиито конструктори са `protected/private`
[^attack]: Може да бъдат реализирани няколко метода или само един - в зависимост от това как сте реализирали останалата част от задачата
[^polymorphicvector]: vector<Entity*> за да е полиморфен контейнер
[^singleton]: Екстра (НЕ носи точки): реализирайте Environment като singleton